# Units in last place

The measurement **ulp** stands for **U**nit in the **L**ast **P**lace, and is a common measurement of mathematical accuracy. [Kahan](/person/kahan)'s original definition of *ulp* in the 1960s was

> $$\text{ulp}(x)$$ is the gap between the two floating-point numbers nearest $$x$$, even if $$x$$ is one of them.

That is, if you take the binary representation of a floating point number and increment it, the difference is 1 ulp.

"Ulp"  was coined to characterize the accuracies of implementations of run-time math library functions on the  IBM 7090 and 7094, which were not as accurate nor fast as they should have been in 1960. By 1964 most of their deficiencies had been repaired by contributions to SHARE (the organized users of  IBM  mainframes), and especially by the work of Hirondo Kuki at the  University of Chicago.

> <small className="text-gray-500">Kahan, 2004</small><br/>
> From time to time, well-intentioned attempts to speed up a math library introduced inaccuries so large that Fred Gustavson  at IBM Yorktown Heights  coined the word  "GULP"  (Giga-Ulp)  to describe them.  Today, there is no excuse for a math library less accurate than the  Freely Distributed Math Library `fdlibm`, promulgated from  Sun Microsystems mostly by graduates from the  University of California at Berkeley, who created the libraries distributed with 4.3 BSD Berkeley UNIX in the  1980s.

By then the adoption of [IEEE Standard 754](/spec/ieee/754) had made infinities and NaNs so ubiquitous that the definition of an ulp had to be changed:

> $$\text{ulp}(x)$$ is the gap between the two *finite* floating-point numbers nearest $$x$$, even if $$x$$ is one of them, and $$\text{ulp}(NaN)$$  is  $$NaN$$.

E.g.,  for  IEEE 754 Double Precision  (8 bytes wide)  as in  MATLAB,
ulp(1) = eps/2,  ulp(1.5) = eps,  ulp(inf) = 2^971,  ulp(0) = 2^-1074 .


## Why finite?

Without this word we would have  ulp(Infinity) = Infinity , which is not too bad but not so good in situations like the following: 

For any finite floating-point number $$y$$, we expect the computed values $$x = (y - \text{ulp}(y) \text{ rounded})$$ and $$z = (y + \text{ulp}(y) \text{ rounded})$$ to satisfy the inequality $$x \leq y \leq z$$. However, we cannot always expect the strict inequality $$x < y < z$$ to hold. For instance, when $$y = 1$$, the IEEE 754 standard rounds midway cases to the nearest even number, resulting in $$z = 1$$. These inferences are also applicable to decimal floating-point numbers, albeit for different reasons.

By defining $$\text{ulp}(\infty)$$ as finite, we maintain these inferences even when $$y$$ is infinite; otherwise, they would be invalidated. When $$y$$ is finite, tighter inferences are possible: either $$x < y \leq z$$, $$x \leq y < z$$, or both.

If $$y$$ is infinite, both strict inequalities are false, yet no invalid operation occurs. If $$\text{ulp}(\infty)$$ were infinite, subtracting it from $$y$$ would result in an invalid operation, producing $$\text{NaN}$$, and further invalid comparisons between $$x$$ and $$y$$ would occur. Such gratuitous invalid operations could disrupt a program significantly, except in environments like MATLAB where this is handled gracefully.

Here is a vectorized MATLAB program to compute `ulp(x)` on machines whose arithmetics conform to [IEEE Standard 754](/spec/ieee/754), as almost all do now.

```matlab
function  u = ulp(x)
%  ulp(x)  is the gap between the two finite floating-point numbers
%  nearest  x ,  even if  x  is one of them.  ulp(NaN)  is  NaN .  E.g.,
%  ulp(1) = eps/2,  ulp(1.5) = eps,  ulp(inf) = 2^971,  ulp(0) = 2^-1074

u = abs(real(x)) ;                  %... to propagate  NaN
k = ( u < 5.0e-308 ) ;              %... copes with  x  too near  0
if any(k(:)),  v = k*5.0e-324 ;  u(k) = v(k) ;  end
j = ( 9.0e307 < u ) ;               %... copes with  x  near  Infinity
if any(j(:)),  v = j*(2^(1024-53)) ;  u(j) = v(j) ;  end
j = ~(j|k) ;                        %... copes with the rest
if any(j(:))
    v = u(j) ;  w = (0.7*eps)*v ;   %... "0.7"  works for  IEEE 754
    u(j) = min( (v+w)-v, (w-v)+v ) ;  end
if any(imag(x(:))),  u = u + i*ulp(imag(x)) ;  end % recursive call !
```